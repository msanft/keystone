diff --git hw/riscv/boot.c hw/riscv/boot.c
index 52bf8e67de2..72162251020 100644
--- a/hw/riscv/boot.c
+++ b/hw/riscv/boot.c
@@ -31,6 +31,7 @@
 #include "sysemu/qtest.h"
 #include "sysemu/kvm.h"
 #include "sysemu/reset.h"
+#include "hw/riscv/virt.h"

 #include <libfdt.h>

@@ -387,50 +388,80 @@ void riscv_setup_rom_reset_vec(MachineState *machine, RISCVHartArrayState *harts
     int i;
     uint32_t start_addr_hi32 = 0x00000000;
     uint32_t fdt_load_addr_hi32 = 0x00000000;
+    RISCVVirtState *rvs = RISCV_VIRT_MACHINE(machine);

-    if (!riscv_is_32bit(harts)) {
-        start_addr_hi32 = start_addr >> 32;
-        fdt_load_addr_hi32 = fdt_load_addr >> 32;
-    }
-    /* reset vector */
-    uint32_t reset_vec[10] = {
-        0x00000297,                  /* 1:  auipc  t0, %pcrel_hi(fw_dyn) */
-        0x02828613,                  /*     addi   a2, t0, %pcrel_lo(1b) */
-        0xf1402573,                  /*     csrr   a0, mhartid  */
-        0,
-        0,
-        0x00028067,                  /*     jr     t0 */
-        start_addr,                  /* start: .dword */
-        start_addr_hi32,
-        fdt_load_addr,               /* fdt_laddr: .dword */
-        fdt_load_addr_hi32,
-                                     /* fw_dyn: */
-    };
-    if (riscv_is_32bit(harts)) {
-        reset_vec[3] = 0x0202a583;   /*     lw     a1, 32(t0) */
-        reset_vec[4] = 0x0182a283;   /*     lw     t0, 24(t0) */
+    if (rvs->rom) {
+        uint8_t *rom = g_malloc(rom_size);
+        if(!rom) {
+            error_report("could not allocate rom buffer");
+            exit(1);
+        }
+        size_t bl_size = load_image_size(rvs->rom, rom, rom_size);
+        if(bl_size == -1) {
+            error_report("could not get rom size");
+            exit(1);
+        }
+        rom_add_blob_fixed_as("mrom.reset", rom, bl_size,
+                            rom_base, &address_space_memory);
+        g_free(rom);
+        /* we also need the fdt */
+        if(fdt_pack(machine->fdt) ||
+            fdt_totalsize(machine->fdt) >rom_size - bl_size) {
+            error_report("not enough space to store device tree");
+            exit(1);
+        }
+        // word-aligned fdt location
+        size_t fdt_loc = rom_base + bl_size;
+        fdt_loc = ((fdt_loc + 0x4 - 1) & ~(0x4 - 1));
+        rom_add_blob_fixed_as("mrom.fdt", machine->fdt, fdt_totalsize(machine->fdt),
+                            fdt_loc, &address_space_memory);
     } else {
-        reset_vec[3] = 0x0202b583;   /*     ld     a1, 32(t0) */
-        reset_vec[4] = 0x0182b283;   /*     ld     t0, 24(t0) */
-    }
+        if (!riscv_is_32bit(harts)) {
+            start_addr_hi32 = start_addr >> 32;
+            fdt_load_addr_hi32 = fdt_load_addr >> 32;
+        }

-    if (!harts->harts[0].cfg.ext_icsr) {
-        /*
-         * The Zicsr extension has been disabled, so let's ensure we don't
-         * run the CSR instruction. Let's fill the address with a non
-         * compressed nop.
-         */
-        reset_vec[2] = 0x00000013;   /*     addi   x0, x0, 0 */
-    }
+        if (!harts->harts[0].cfg.ext_icsr) {
+            /*
+            * The Zicsr extension has been disabled, so let's ensure we don't
+            * run the CSR instruction. Let's fill the address with a non
+            * compressed nop.
+            */
+            reset_vec[2] = 0x00000013;   /*     addi   x0, x0, 0 */
+        }

-    /* copy in the reset vector in little_endian byte order */
-    for (i = 0; i < ARRAY_SIZE(reset_vec); i++) {
-        reset_vec[i] = cpu_to_le32(reset_vec[i]);
+        /* reset vector */
+        uint32_t reset_vec[10] = {
+            0x00000297,                  /* 1:  auipc  t0, %pcrel_hi(fw_dyn) */
+            0x02828613,                  /*     addi   a2, t0, %pcrel_lo(1b) */
+            0xf1402573,                  /*     csrr   a0, mhartid  */
+            0,
+            0,
+            0x00028067,                  /*     jr     t0 */
+            start_addr,                  /* start: .dword */
+            start_addr_hi32,
+            fdt_load_addr,               /* fdt_laddr: .dword */
+            fdt_load_addr_hi32,
+                                        /* fw_dyn: */
+        };
+        if (riscv_is_32bit(harts)) {
+            reset_vec[3] = 0x0202a583;   /*     lw     a1, 32(t0) */
+            reset_vec[4] = 0x0182a283;   /*     lw     t0, 24(t0) */
+        } else {
+            reset_vec[3] = 0x0202b583;   /*     ld     a1, 32(t0) */
+            reset_vec[4] = 0x0182b283;   /*     ld     t0, 24(t0) */
+        }
+
+        /* copy in the reset vector in little_endian byte order */
+        for (i = 0; i < ARRAY_SIZE(reset_vec); i++) {
+            reset_vec[i] = cpu_to_le32(reset_vec[i]);
+        }
+        rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+                            rom_base, &address_space_memory);
+        riscv_rom_copy_firmware_info(machine, rom_base, rom_size, sizeof(reset_vec),
+                                    kernel_entry);
     }
-    rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
-                          rom_base, &address_space_memory);
-    riscv_rom_copy_firmware_info(machine, rom_base, rom_size, sizeof(reset_vec),
-                                 kernel_entry);
+    return;
 }

 void riscv_setup_direct_kernel(hwaddr kernel_addr, hwaddr fdt_addr)
diff --git a/hw/riscv/virt.c b/hw/riscv/virt.c
index 4e3efbee16f..56053a91d1f 100644
--- a/hw/riscv/virt.c
+++ b/hw/riscv/virt.c
@@ -76,7 +76,7 @@

 static const MemMapEntry virt_memmap[] = {
     [VIRT_DEBUG] =        {        0x0,         0x100 },
-    [VIRT_MROM] =         {     0x1000,        0xf000 },
+    [VIRT_MROM] =         {     0x1000,        0x40000 },
     [VIRT_TEST] =         {   0x100000,        0x1000 },
     [VIRT_RTC] =          {   0x101000,        0x1000 },
     [VIRT_CLINT] =        {  0x2000000,       0x10000 },
@@ -1615,6 +1615,19 @@ static void virt_set_aclint(Object *obj, bool value, Error **errp)
     s->have_aclint = value;
 }

+static char *virt_get_rom(Object *obj, Error **errp)
+{
+    RISCVVirtState *rvs = RISCV_VIRT_MACHINE(obj);
+    return g_strdup(rvs->rom);
+}
+
+static void virt_set_rom(Object *obj, const char *value, Error **errp)
+{
+    RISCVVirtState *rvs = RISCV_VIRT_MACHINE(obj);
+    g_free(rvs->rom);
+    rvs->rom = g_strdup(value);
+}
+
 bool virt_is_acpi_enabled(RISCVVirtState *s)
 {
     return s->acpi != ON_OFF_AUTO_OFF;
@@ -1713,6 +1726,10 @@ static void virt_machine_class_init(ObjectClass *oc, void *data)
                               NULL, NULL);
     object_class_property_set_description(oc, "acpi",
                                           "Enable ACPI");
+    object_class_property_add_str(oc, "rom",
+                              virt_get_rom, virt_set_rom);
+    object_class_property_set_description(oc, "rom",
+                              "ROM image");
 }

 static const TypeInfo virt_machine_typeinfo = {
diff --git a/include/hw/riscv/virt.h b/include/hw/riscv/virt.h
index e5c474b26eb..474a67ed9de 100644
--- a/include/hw/riscv/virt.h
+++ b/include/hw/riscv/virt.h
@@ -56,6 +56,7 @@ struct RISCVVirtState {
     bool have_aclint;
     RISCVVirtAIAType aia_type;
     int aia_guests;
+    char *rom;
     char *oem_id;
     char *oem_table_id;
     OnOffAuto acpi;
